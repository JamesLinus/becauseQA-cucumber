/*
* generated by Xtext
*/
package org.becausecucumber.eclipse.plugin.ui.quickfix;

import java.util.ArrayList;
import java.util.List;

import org.becausecucumber.eclipse.plugin.common.CommonPluginUtils;
import org.becausecucumber.eclipse.plugin.common.console.Log;
import org.becausecucumber.eclipse.plugin.common.searcher.PerformSearcher;
import org.becausecucumber.eclipse.plugin.common.searcher.PerformSearcher.Entry;
import org.becausecucumber.eclipse.plugin.validation.CucumberJavaValidator;
import org.becausecucumber.eclipse.plugin.cucumber.Step;
import org.becausecucumber.eclipse.plugin.ui.CucumberPeopleActivator;
import org.becausecucumber.eclipse.plugin.ui.common.CucumberUtils;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.search.internal.ui.text.EditorOpener;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.IWorkbench;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.xtext.ui.editor.model.edit.IModificationContext;
import org.eclipse.xtext.ui.editor.model.edit.ISemanticModification;
import org.eclipse.xtext.ui.editor.quickfix.Fix;
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor;
import org.eclipse.xtext.validation.Issue;

import com.google.inject.Inject;

/**
 * Custom quickfixes.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#quickfixes update
 * history:
 * 
 * 2015.05.19 : add the file name index
 */
public class CucumberQuickfixProvider extends org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider {

	// @Fix(MyJavaValidator.INVALID_NAME)
	// public void capitalizeName(final Issue issue, IssueResolutionAcceptor
	// acceptor) {
	// acceptor.accept(issue, "Capitalize name", "Capitalize the name.",
	// "upcase.png", new IModification() {
	// public void apply(IModificationContext context) throws
	// BadLocationException {
	// IXtextDocument xtextDocument = context.getXtextDocument();
	// String firstLetter = xtextDocument.get(issue.getOffset(), 1);
	// xtextDocument.replace(issue.getOffset(), 1, firstLetter.toUpperCase());
	// }
	// });
	// }

	@Inject
	private PerformSearcher matcher;

	@Override
	protected String fixCrossReferenceImage(String issueString, String replacement) {
		// TODO Auto-generated method stub
		return super.fixCrossReferenceImage(issueString, replacement);
	}

	/*
	 * this is correcting the multiple steps
	 */
	@Fix(CucumberJavaValidator.MULTILE_STEP)
	public void correctStep(Issue issue, IssueResolutionAcceptor acceptor) {
		String description = issue.getData()[0];

		final CucumberCounter counter = new CucumberCounter();
		matcher.matcher(description, counter);
		List<Entry> entries = counter.getFiles();

		Log.info("Cucumber Fix- will delete the multile steps found in current workspace...");
		// List<LineItem> searchlist = searcher.validateJob(parserstep);
		for (Entry entry : entries) {
			int offset = entry.getOffset();
			int length = entry.getLength();
			IFile file = entry.getFile();

			acceptor.accept(issue, "Delete duplicated step in file " + file.getName() + ", step offset: " + offset,
					"Description:\nIt will delete current step defination in the file:\n"
							+ file.getFullPath().toOSString(),
					"delete.gif", new DeleteMoidifacation(file, offset, length));
		}
	}

	/*
	 * this is used for creating the new step
	 */
	@Fix(CucumberJavaValidator.NO_DEFINATION_STEP)
	public void defintedStep(final Issue issue, IssueResolutionAcceptor acceptor) {
		// String message = issue.getMessage();
		// String description = issue.getData()[0];

		final IWorkbench workbench = CommonPluginUtils.getInstance();
		/*
		 * CommonSearcher searcher=new CommonSearcher();
		 * 
		 * final IWorkbench workbench = CommonPluginUtils.getInstance();
		 * searcher.validateJob(description); List<IFile>
		 * searchlist=searcher.getStepFiles();
		 */
		acceptor.accept(issue, "1. Create a new step definition file...",
				"Description:\nIt will create the new step definition in a new file", "new.gif",
				new NewModifaction(workbench));

		ArrayList<IResource> allFilesInProject = CommonPluginUtils.getAllFilesInProject();

		int index = 1;
		for (IResource resource : allFilesInProject) {
			if (resource instanceof IFile && ((IFile) resource).getFileExtension() != null) {
				index = index + 1;
				IFile file = (IFile) resource;
				acceptor.accept(issue, index + ". " + file.getName(),
						"Description:\nPut current step in this existing step definition file,\nStep file local abstract path is:"
								+ file.getFullPath().toOSString(),
						"add.gif", new UpdateModifaction(file));
			}

		}

	}

	class DeleteMoidifacation implements ISemanticModification {

		private IFile stepfiles;
		private int offset;
		private int length;

		public DeleteMoidifacation(IFile stepfiles, int offset, int length) {
			// TODO Auto-generated constructor stub
			this.stepfiles = stepfiles;
			this.offset = offset;
			this.length = length;
		}

		@Override
		public void apply(EObject element, IModificationContext context) throws Exception {
			// TODO Auto-generated method stub
			Log.info("Will delete the duplicated step definition in this file:" + stepfiles.getFullPath().toOSString()
					+ ",offset is:" + this.offset + ",length is: " + this.length);
			EditorOpener opener = new EditorOpener();
			IWorkbenchPage page = CucumberPeopleActivator.getInstance().getWorkbench().getActiveWorkbenchWindow()
					.getActivePage();
			if (page != null) {
				opener.openAndSelect(page, stepfiles, offset, length, true);
			} else {
				Log.error("Cannot init the IWorkbenchPage object: " + page);
			}
		}

	}

	/**
	 * @author alter
	 *
	 */
	/**
	 * @ClassName: NewModifaction
	 * @Description: TODO
	 * @author alterhu2020@gmail.com
	 * @date Jun 27, 2015 7:01:50 PM
	 * 
	 */

	class NewModifaction implements ISemanticModification {

		private IWorkbench workbench;

		public NewModifaction(IWorkbench workbench) {
			// TODO Auto-generated constructor stub
			this.workbench = workbench;
		}

		@Override
		public void apply(EObject element, IModificationContext context) throws Exception {
			// TODO Auto-generated method stub

			// IStructuredSelection selection =
			// CommonPluginUtils.getActiveIStructuredSelection();
			Shell shell = CommonPluginUtils.getShell();
			IProject project = CommonPluginUtils.getActiveProject();
			// IFile selectedfile =CommonPluginUtils.getActiveEditorPath();
			boolean isjava = CommonPluginUtils.isJavaNatureProject(project);
			Step step = (Step) element;
			if (step != null) {
				// System.out.println("line showing content
				// is:"+stepdes.getDescription());
				Log.info("Cucumber Fix- Fix the no definition step : " + step.getDescription());
				if (!isjava) {
					CucumberUtils.createRubyFile(workbench, step);
				} else {
					IJavaProject newproject = CommonPluginUtils.getJavaProject(project);
					CucumberUtils.createJavaFile(newproject, step);
				}
			} else {
				MessageDialog.openError(shell, "Cucumber Step Description Checker",
						"Current Cucumber Step Description is null");
			}

		}

	}

	class UpdateModifaction implements ISemanticModification {

		private IFile file;

		public UpdateModifaction(IFile file) {
			this.file = file;

		}

		@Override
		public void apply(EObject element, IModificationContext context) throws Exception {
			// TODO Auto-generated method stub

			Step stepdes = (Step) element;
			IWorkbenchPage page = CommonPluginUtils.getActivePage();
			IProject project = CommonPluginUtils.getActiveProject();
			// IFile selectedfile =CommonPluginUtils.getActiveEditorPath();
			boolean isjava = CommonPluginUtils.isJavaNatureProject(project);
			if (isjava) {
				CucumberUtils.addJavaFileContent(page, file, stepdes);
			} else {
				CucumberUtils.addRubyFileContent(page, file, stepdes);
			}
		}

	}

	private final static class CucumberCounter implements PerformSearcher.MatcherCollector {

		@SuppressWarnings("unused")
		private int count = 0;
		private List<Entry> files = new ArrayList<Entry>();

		public List<Entry> getFiles() {
			return files;
		}

		@Override
		public void foundMatcher(Entry entry) {
			// TODO Auto-generated method stub
			count++;
			files.add(entry);
		}

	}

}
